#' @title Shpilkin's Method
#' @description This function implements the revised version of Shpilkin's method (NB! It doesn't replicate original method fully).
#' @usage ComputeShpilkinMethod(data, Candidates, CandidatesText = NULL, MainCandidate, TotalReg, TotalVotes=NULL,
#'                              Level = NULL, Methodmax = "M1", WindowSize = 5, MaxtThreshold = 0.8, FigureName,  Colors = NULL)
#' @param data electoral data.
#' @param Candidates vector of variable names for all candidates/parties participated in the election
#' @param CandidatesText vector of candidates/parties' names participated in the election used to draw the figure
#' @param MainCandidate variable name for main/incumbent candidate
#' @param TotalReg  variable name for the total number of eligible voters
#' @param TotalVotes variable name for the total number of ballots cast (if ommited, computed based on the votes for Candidates)
#' @param Level variable name depicting the level of analysis ("National", i.e. whole dataset by default)
#' @param Methodmax clean peak search
#' \itemize{
#'   \item M0 - absolute clean peak search on the left handside from official turnout
#'   \item M1 - absolute clean peak search on the left handside from official turnout with k-means clustering
#'   \item M2 - relative search on the left handside from official turnout within a range defined by WindowSize
#' }
#' @param WindowSize define WindowSize for M0 and M1.  Algorithm searches for max value change within prespecified WindowSize (by default WindowSize=5\%)
#' @param MaxtThreshold  anomalous turnout threshold (by default 0.8)
#' @param FigureName  figure's name
#' @param Colors vector of colors per each candidate/party (Colors=NULL, i.e. randomly generated by default)
#' @export
#' @import ggplot2
#' @return list containing results of analysis
#' \itemize{
#'   \item list_graphs - list of graphs
#'   \item stats_summary -  table with results for analysis of the whole dataset (for Level!=NULL: data are also
#'                          summed across the units, aggregation error is computed)
#'   \item Level -  external parameter
#'   \item creationdate - date/time of analysis
#'   list_graphs = list_graphs, stats_summary = stats_table, stats_level=stats_level
#' }
#' @examples
#' library(EFToolkit)
#'
#' dat<-read.csv(system.file("ruspres2018.csv", package="EFToolkit"))
#' res<-ComputeShpilkinMethod(dat, Candidates=c("P1", "P2",  "P3",  "P4", "P5", "P6", "P7", "P8" ),
#'                     CandidatesText=c("Baburin", "Grudinin",  "Zhirinovsky",  "Putin", "Sobchak",
#'                              "Suraikin", "Titov", "Yavlinsky"),
#'                     MainCandidate="P4",
#'                     TotalReg="NVoters",
#'                     TotalVotes=c('C9', 'C10'),
#'                     Methodmax="M1",
#'                     FigureName="Russian Presidential Elections, 2018",
#'                     Level="region",
#'                     MaxtThreshold=0.85)


############################################################
##               Election Forensics Toolkit               ##
##  24oct2019, 2nov2019 by Kirill Kalinin                 ##
##  Kirill Kalinin and Walter R. Mebane, Jr               ##
############################################################

ComputeShpilkinMethod<-function(data, Candidates, CandidatesText = NULL,
                                MainCandidate, TotalReg, TotalVotes=NULL,
                                Level = NULL, Methodmax = "M1", WindowSize = 5,
                                MaxtThreshold = 0.8, FigureName, Colors=NULL){


  estimate_fraud<-function(data,Candidates,CandidatesText, MainCandidate, TotalReg, Methodmax,
                           FigureName, WindowSize, MaxtThreshold, whole.real.turnout = NULL, colors){

    MainCandidate.v <- data[,names(data) %in% MainCandidate];
    acandidates.v <- data[,names(data) %in% Candidates];
    mcandidateM <- Candidates %in% MainCandidate

    if(is.null(CandidatesText)) CandidatesText<- Candidates
    ccandidate <- CandidatesText[mcandidateM]

    if(!is.null(TotalVotes)){
      if(length(TotalVotes)>1){
        valid.v <- apply(data[,names(data) %in% TotalVotes], 1, function(x) sum(x, na.rm=TRUE))
      }else{
        valid.v <- data[,names(data) %in% TotalVotes]
      }
    }else{
      valid.v <- apply(acandidates.v, 1, function(x) sum(x, na.rm = TRUE))
    }


    TotalReg.v <- data[,names(data) %in% TotalReg];
    mdat <- data.frame(valid.v, MainCandidate.v,   TotalReg.v, acandidates.v)
    turnout = mdat$valid.v/mdat$TotalReg.v
    official.turnout = sum(mdat$valid.v, na.rm = TRUE)/sum(mdat$TotalReg.v,na.rm = TRUE)
    incumbent.support = sum(mdat$MainCandidate.v , na.rm = TRUE)/sum(mdat$valid.v, na.rm = TRUE)

    candidate_matrix <- matrix(NA,103,length(Candidates))
    valid100 <- registered100 <- mcandidate100 <- rep(NA,103)

    i = 0
    ruler <- seq(0,1.01,.01)
    while(i <= 102){
      candidate_matrix[i+1,]<-sapply(1:length(Candidates), function(j) {
        sum(mdat[,3+j][turnout > ruler[i] & turnout<=ruler[i+1]], na.rm = TRUE)})
      valid100[i+1] <- sum(mdat[,1][turnout > ruler[i] & turnout <= ruler[i+1]], na.rm = TRUE)
      mcandidate100[i+1] <- sum(mdat[,2][turnout > ruler[i]&turnout <= ruler[i+1]], na.rm = TRUE)
      registered100[i+1] <- sum(mdat[,3][turnout > ruler[i]&turnout <= ruler[i+1]], na.rm = TRUE)
      i = i + 1
    }

    #adjustment
    candidate_matrix <- candidate_matrix[-c(1, 103),]; ruler = ruler[-101]
    valid100 <- valid100[-c(1, 103)];
    registered100 <- registered100[-c(1, 103)];
    mcandidate100 <- mcandidate100[-c(1, 103)];

    percentMainCandidateSupport <-  mcandidate100 / valid100

    if(Methodmax == "M0"){
      peaky <- ruler[!is.na(percentMainCandidateSupport)]
      max_height <-   mcandidate100[which(ruler %in% peaky)]
      peaks_matrix <- data.frame(peaky, max_height)
      peaks_matrix_less <- peaks_matrix[peaky < official.turnout,]
      max.peak.turnout <- peaks_matrix_less$peaky[which.max(peaks_matrix_less$max_height)]
    }

    if(Methodmax == "M1"){
      peaky <- ruler[!is.na(percentMainCandidateSupport)]
      max_height <-   mcandidate100[which(ruler %in% peaky)]
      peaks_matrix <- data.frame(peaky, max_height)
      peaks_matrix_less <- peaks_matrix[peaky < official.turnout,]
      peaks.v<-peaks_matrix_less$peaky[which(sign(diff(peaks_matrix_less$max_height))==-1)]

      if(length(peaks.v)<3){
        max.peak.turnout <- peaks_matrix_less$peaky[which.max(peaks_matrix_less$max_height)]
      }else{
        cl.fit <- kmeans(peaks.v, 2)
        max.peak.turnout<-peaks.v[cl.fit$cluster==median(cl.fit$cluster)][1]
      }
      if (is.na(max.peak.turnout)){
        max.peak.turnout <- peaks_matrix_less$peaky[which.max(peaks_matrix_less$max_height)]
      }
    }

    if(Methodmax == "M2"){
      peaky <- ruler[which(sign(diff(percentMainCandidateSupport)) == 1)]
      stepp <- c(0,diff(peaky))
      max_height <- mcandidate100[which(ruler %in% peaky)]
      peaks_matrix <- data.frame(peaky, stepp, max_height)
      peaks_matrix_less <- peaks_matrix[peaky < official.turnout,]

      i=0
      l=dim(peaks_matrix_less)[1]

      if(length(peaks_matrix_less$peaky) < WindowSize){
        WindowSize = length(peaks_matrix_less$peaky);
        warning("adjusting for a Window size")}

      k <- which.max(peaks_matrix_less$max_height)

      while((l - i - WindowSize + 1) > 0){
        selected = seq(l - i, l - i - WindowSize + 1, -1)
        if(any(peaks_matrix_less$stepp[selected] > 0.01)){
          o <- which.max(peaks_matrix_less$stepp[selected])
          p <- o[length(o)]
          k <- selected[p]
          break
        }
        i = i + 1
      }
      max.peak.turnout = peaks_matrix_less$peaky[k]
    }

    if(is.null(whole.real.turnout)) whole.real.turnout <- max.peak.turnout

    if(official.turnout > MaxtThreshold & !is.null(whole.real.turnout)){
      max.peak.turnout <- whole.real.turnout}

    mat100 <- length(candidate_matrix[,1])
    clean.votes <- candidate_matrix[which(ruler == max.peak.turnout),mcandidateM]
    clean.valid.votes <- sum(candidate_matrix[which(ruler == max.peak.turnout),], na.rm=TRUE)
    clean.all.butMainCandidate <- valid100[which(ruler == max.peak.turnout)] -
      candidate_matrix[which(ruler == max.peak.turnout), mcandidateM]
    clean.ur.prop <- clean.votes/clean.valid.votes
    clean.all.butMainCandidate.prop <- 1 - clean.ur.prop
    inflation.factor <- clean.votes / clean.all.butMainCandidate
    clean.votes.vector <- (valid100 - candidate_matrix[, mcandidateM]) * inflation.factor
    clean.votes.total <- sum(clean.votes.vector, na.rm=TRUE)

    if (max.peak.turnout > 1){k1 = 1}else{k1 = 100}

    magnitude.election.fraud<-
      sum(candidate_matrix[(round(max.peak.turnout * k1 + 1, 0)):101, mcandidateM], na.rm=TRUE) -
      sum(clean.votes.vector[(round(max.peak.turnout * k1 + 1, 0)):101], na.rm=TRUE)

    realMainCandidateSupport <- round(percentMainCandidateSupport[round(max.peak.turnout * k1, 0) + 1]*100, 0)

    ballot_stuffing <- round((official.turnout - max.peak.turnout) * sum(mdat$TotalReg.v,na.rm = TRUE), 0)
    if(ballot_stuffing > magnitude.election.fraud){ballot_stuffing <- round(magnitude.election.fraud, 0)}
    ballot_switching <- round((magnitude.election.fraud - ballot_stuffing) / 2, 0)

    colV <- as.vector(matrix(rep(colors,each = mat100),nrow = mat100))

    #party vector
    if(length(clean.votes.vector) == 0){clean.votes.vector = 0}
    ggparties <- cbind(clean.votes.vector, candidate_matrix)
    votV <- as.vector(as.matrix(ggparties))

    rulV <- rep(ruler*100, times = dim(ggparties)[2])

    namV <- as.vector(
      matrix(rep(c("Clean votes", paste("P/C: ", CandidatesText, sep = "")),
                 each = mat100),nrow = mat100))
    #CI
    u <- ifelse(namV == "Clean votes", votV, NA)
    l <- ifelse(namV == paste("P/C: ", ccandidate, sep = ""), votV, NA);
    lna <- rep(NA,length(namV)); if(!all(is.na(l))) lna[1:101] <- l[!is.na(l)]
    l <- lna

    ggdata <- data.frame(namV, rulV, colV, votV, u, l)
    o.turnout <- round(official.turnout*100,digits = 1)
    r.turnout <- round(max.peak.turnout*100,digits = 1)
    turnout.info <- paste("Official turnout: ",
                          round(o.turnout,digits = 1), "%",
                          "   Real turnout: ",
                          round(r.turnout,digits = 1), "%", sep = "")
    support.info <- paste("Official support: ",
                          round(incumbent.support * 100, 1), "%",
                          "   Real support: ",
                          round(realMainCandidateSupport, digits = 1), "%", sep = "")
    m.fraud.info <- paste("Fraud: ", round(magnitude.election.fraud, 0), sep = "")

    names(colors) <-unique(namV)
    colScale <- scale_colour_manual(name = "namV", values = colors)

    drawfig <- ggplot(ggdata, aes(x = rulV, y = votV, color = namV, group = namV)) +
      scale_x_discrete(limits = seq(0,100,10)) +
      theme_bw() +
      geom_vline(aes(xintercept = o.turnout), color="blue", linetype="dashed", size = 1, show.legend = F) +
      geom_vline(aes(xintercept = r.turnout), color="grey", linetype="dashed", size = 1, show.legend = F) +
      geom_line(size = 2, na.rm=TRUE) +
      colScale +
      geom_ribbon(aes(ymin = l,ymax = u), fill = "grey", alpha = 0.5, show.legend = F, color = NA)+
      theme(legend.title = element_blank(),
            legend.text = element_text(size = 10),
            legend.key = element_blank(),
            legend.background = element_blank()) +
      labs(title = FigureName,
           y = "Number of Votes", x = "Turnout") +
      theme(plot.title = element_text(hjust = 0.5)) +
      labs(caption = paste("\n", turnout.info,"\n",
                           support.info,"\n",
                           m.fraud.info, sep = ""))

    fraud_measure <- round(magnitude.election.fraud, 0)
    votes_incumbent <- sum(mdat$MainCandidate.v)

    results <- list(official_turnout = o.turnout, real_turnout = r.turnout,
                    official_support = round(incumbent.support*100, 1), real_support = round(realMainCandidateSupport, 1),
                    ballot_stuffing = ballot_stuffing, ballot_switching = ballot_switching,
                    total_fraud = fraud_measure, drawfig = drawfig)
    return(results)}

  gresults <- list()

  gen_colors <- function(Candidates, MainCandidate){
    colors.v = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
    colors.v <- sample(colors.v,  length(Candidates))
    colors.v[which(Candidates%in%MainCandidate)] <- "chartreuse4"
    colors.v <- c("grey", colors.v)
    return(colors.v)}

  if(is.null(Colors)){
    colors.v <- gen_colors(Candidates=Candidates, MainCandidate=MainCandidate)
  }else{
    if(length(Colors)!=length(Candidates)){
      colors.v <- gen_colors(Candidates=Candidates, MainCandidate=MainCandidate)
    }else{
      colors.v <- c("grey", Colors)
    }
  }

  if(!is.null(Level)){
    gresults[['Whole dataset']] <- estimate_fraud(data, Candidates, CandidatesText,
                                                  MainCandidate, TotalReg, Methodmax,
                                                  FigureName, WindowSize,
                                                  MaxtThreshold, colors=colors.v)

    whole.real.turnout <- gresults[['Whole dataset']]$real_turnout/100

    if(Level!="National"){
      splby <- data[,names(data) %in% Level]
      mdat <- split(data, splby)

      for(i in 1:length(names(mdat))){
        mitem <- mdat[[i]]
        FigureName <- names(mdat)[i]
        gresults[[FigureName]] <- estimate_fraud(mitem,Candidates,CandidatesText,
                                                 MainCandidate, TotalReg, Methodmax,
                                                 FigureName, WindowSize,
                                                 whole.real.turnout = whole.real.turnout,
                                                 MaxtThreshold, colors=colors.v)
      }
    }

  }else{

    gresults[['Whole dataset']] <- estimate_fraud(data,Candidates,CandidatesText,
                                                  MainCandidate, TotalReg, Methodmax,
                                                  FigureName, WindowSize,
                                                  MaxtThreshold, colors=colors.v)
  }

  lst_lngth <- length(gresults[[1]])
  list_graphs  <-  lapply(gresults, function(x) x[[lst_lngth]])
  stats_table  <-  do.call(rbind.data.frame,
                           lapply(gresults, function(x) x[1:(lst_lngth - 1)]))


  if (!is.null(Level)) {
    stats_level <- stats_table[-1, ]
    stats_whole <- stats_table[1, ]
    stats_agg_level <- c(apply(stats_level[, 1:4], 2, function(x) round(mean(x, na.rm=TRUE), 1)),
                         apply(stats_level[, 5:7], 2, function(x) round(sum(x, na.rm=TRUE), 1)))

    diff_whole_agg <- stats_whole-stats_agg_level
    stats_table <- rbind(stats_whole, stats_agg_level, diff_whole_agg)
    rownames(stats_table) <- c("stats with whole data", "stats aggregated from level", "aggregation error")

  }else{
    stats_level <- NULL
  }

  list_results <- list(list_graphs = list_graphs, stats_summary = stats_table, stats_level=stats_level,
                       Level = Level, creationdate = Sys.time())
}
